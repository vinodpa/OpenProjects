###################################################################
##
## Name     : axi_hostinterface
## Desc     : Microprocessor Peripheral Description
##          : Automatically generated by PsfUtility
##
###################################################################

BEGIN axi_hostinterface

## Peripheral Options
OPTION IPTYPE = PERIPHERAL
OPTION IMP_NETLIST = TRUE
OPTION HDL = VHDL
OPTION IP_GROUP = 'Industrial Ethernet:MICROBLAZE:PPC'
OPTION DESC = AXI_HOSTINTERFACE
OPTION ARCH_SUPPORT_MAP = (others=DEVELOPMENT)


## Bus Interfaces
BUS_INTERFACE BUS = S_AXI_PCP, BUS_STD = AXI, BUS_TYPE = SLAVE
BUS_INTERFACE BUS = S_AXI_HOST, BUS_STD = AXI, BUS_TYPE = SLAVE ,  ISVALID = (gHostIfType == 0)
BUS_INTERFACE BUS = M_AXI_PCP, BUS_STD = AXI, BUS_TYPE = MASTER

##IO Interface
IO_INTERFACE IO_IF = PAP, IO_TYPE = XIL_GPIO_V1
IO_INTERFACE IO_IF = LED, IO_TYPE = XIL_GPIO_V1

## Generics for VHDL or Parameters for Verilog
## Generic for PCP Host interface
PARAMETER C_S_AXI_PCP_DATA_WIDTH = 32, DT = INTEGER, BUS = S_AXI_PCP, ASSIGNMENT = CONSTANT
PARAMETER C_S_AXI_PCP_ADDR_WIDTH = 32, DT = INTEGER, BUS = S_AXI_PCP, ASSIGNMENT = CONSTANT
PARAMETER C_S_AXI_PCP_MIN_SIZE = 0x0001ffff, DT = std_logic_vector, BUS = S_AXI_PCP
PARAMETER C_BASEADDR = 0xffffffff, DT = std_logic_vector, MIN_SIZE = 0x10000, PAIR = C_HIGHADDR, ADDRESS = BASE, BUS = S_AXI_PCP
PARAMETER C_HIGHADDR = 0x00000000, DT = std_logic_vector, PAIR = C_BASEADDR, ADDRESS = HIGH, BUS = S_AXI_PCP
PARAMETER C_FAMILY = virtex6, DT = STRING, BUS = S_AXI_PCP
PARAMETER C_S_AXI_PCP_PROTOCOL = AXI4LITE, TYPE = NON_HDL, ASSIGNMENT = CONSTANT, DT = STRING, BUS = S_AXI_PCP

## Generic for Host processor interface
PARAMETER C_S_AXI_HOST_DATA_WIDTH = 32, DT = INTEGER, BUS = S_AXI_HOST, ASSIGNMENT = CONSTANT , ISVALID = (gHostIfType == 0)
PARAMETER C_S_AXI_HOST_ADDR_WIDTH = 32, DT = INTEGER, BUS = S_AXI_HOST, ASSIGNMENT = CONSTANT , ISVALID = (gHostIfType == 0)
PARAMETER C_S_AXI_HOST_MIN_SIZE = 0x0001ffff, DT = std_logic_vector, BUS = S_AXI_HOST , ISVALID = (gHostIfType == 0)
PARAMETER C_HOST_BASEADDR = 0xffffffff, DT = std_logic_vector, MIN_SIZE = 0x10000, PAIR = C_HOST_HIGHADDR, ADDRESS = BASE, BUS = S_AXI_HOST, ISVALID = (gHostIfType == 0)
PARAMETER C_HOST_HIGHADDR = 0x00000000, DT = std_logic_vector, PAIR = C_HOST_BASEADDR, ADDRESS = HIGH, BUS = S_AXI_HOST, ISVALID = (gHostIfType == 0)
PARAMETER C_HOST_FAMILY = virtex6, DT = STRING, BUS = S_AXI_HOST, ISVALID = (gHostIfType == 0)
PARAMETER C_S_AXI_HOST_PROTOCOL = AXI4LITE, TYPE = NON_HDL, ASSIGNMENT = CONSTANT, DT = STRING, BUS = S_AXI_HOST, ISVALID = (gHostIfType == 0)

## Generic used for Master Bridge
PARAMETER C_M_AXI_ADDR_WIDTH  = 32, DT = INTEGER, BUS = M_AXI_PCP, ASSIGNMENT = CONSTANT
PARAMETER C_M_AXI_DATA_WIDTH  = 32, DT = INTEGER, BUS = M_AXI_PCP, ASSIGNMENT = CONSTANT
PARAMETER C_M_AXI_PROTOCOL = AXI4Lite, DT = string, TYPE = NON_HDL, ASSIGNMENT = CONSTANT, BUS = M_AXI_PCP
PARAMETER C_M_AXI_SUPPORTS_READ = 1, DT = integer, ASSIGNMENT = CONSTANT, TYPE = NON_HDL, BUS = M_AXI_PCP
PARAMETER C_M_AXI_SUPPORTS_WRITE = 1, DT = integer, ASSIGNMENT = CONSTANT, TYPE = NON_HDL, BUS = M_AXI_PCP

## Generics used for Host Interface IP

PARAMETER gHostIfType = 1, DT = INTEGER, RANGE = (0:1), VALUES = (0 = "Internal AXI Bus", 1 = "Parallel Interface" )
PARAMETER gVersionMajor = 0xFF, DT = INTEGER, RANGE = (0:65535), ASSIGNMENT = CONSTANT
PARAMETER gVersionMinor = 0xFF, DT = INTEGER, RANGE = (0:65535), ASSIGNMENT = CONSTANT
PARAMETER gVersionRevision = 0xFF, DT = INTEGER, RANGE = (0:65535), ASSIGNMENT = CONSTANT
PARAMETER gVersionCount = 0x0, DT = INTEGER, RANGE = (0:65535), ASSIGNMENT = CONSTANT
##Generic for Parallel Interface IP
PARAMETER gParallelDataWidth = 16, DT = INTEGER, RANGE = (16,32), ISVALID = (gHostIfType == 1)
PARAMETER gParallelMultiplex = 0, DT = INTEGER, RANGE = (0:1), VALUES = (0 = "Demultiplexed", 1 = "Multiplexed"), ISVALID = (gHostIfType == 1),
## Buffer Managements
PARAMETER gBaseDynBuf0  = 0x800, DT = INTEGER, ASSIGNMENT = CONSTANT
PARAMETER gBaseDynBuf1  = 0x01000, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_dbuf1
PARAMETER gBaseErrCntr = 0x01800, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_Errcntr
PARAMETER gBaseTxNmtQ = 0x02800, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_TxNmtQ
PARAMETER gBaseTxGenQ = 0x03800, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_TxGenQ
PARAMETER gBaseTxSynQ = 0x04800, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_TxSynQ
PARAMETER gBaseTxVetQ = 0x05800, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_TxVetQ
PARAMETER gBaseRxVetQ = 0x06800, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_RxVetQ
PARAMETER gBaseK2UQ = 0x07000, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_K2UQ
PARAMETER gBaseU2KQ = 0x09000, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_U2KQ
PARAMETER gBaseTpdo = 0x0B000, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_Tpdo
PARAMETER gBaseRpdo = 0x0E000, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_Rpdo
PARAMETER gBaseRes = 0x14000, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_baseadr_Res

## Other Parameters that Used In GUI
PARAMETER gTotalMem = 49152, DT = INTEGER, TYPE = NON_HDL, IPLEVEL_UPDATE_VALUE_PROC = calc_total_memory

PARAMETER Size_KB_DynBuf0 = 2, DT = INTEGER, RANGE = (2)
PARAMETER Size_KB_DynBuf1 = 2, DT = INTEGER, RANGE = (2)
PARAMETER Size_B_ErrorCounter = 3108, DT = INTEGER, RANGE = (36,3108,1024,2048,4096,8192), VALUES = (36= "CN" , 3108 = "MN", 1024 = "1024", 2048 = "2048", 4096 = "4096", 8192 = "8192")
PARAMETER Size_KB_TxNmtQ = 2, DT = INTEGER, RANGE = (1,2,4,8,16,32,64)
PARAMETER Size_KB_TxGenQ = 2, DT = INTEGER, RANGE = (1,2,4,8,16,32,64)
PARAMETER Size_KB_TxSynQ = 2, DT = INTEGER, RANGE = (1,2,4,8,16,32,64)
PARAMETER Size_KB_TxVetQ = 2, DT = INTEGER, RANGE = (1,2,4,8,16,32,64)
PARAMETER Size_KB_RxVetQ = 1, DT = INTEGER, RANGE = (1,2,4,8,16,32,64)
PARAMETER Size_KB_K2UQ = 8, DT = INTEGER, RANGE = (1,2,4,8,16,32,64)
PARAMETER Size_KB_U2KQ = 8, DT = INTEGER, RANGE = (1,2,4,8,16,32,64)
PARAMETER Size_B_Tpdo = 12288, DT = INTEGER
PARAMETER Size_B_Rpdo = 24576, DT = INTEGER

PARAMETER Conv_Size_KB_DynBuf0 = 2, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_dbuf0
PARAMETER Conv_Size_KB_DynBuf1 = 2, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_dbuf0
PARAMETER Conv_Size_B_ErrorCounter = 3108, DT = INTEGER,IPLEVEL_UPDATE_VALUE_PROC = calc_size_Errcntr
PARAMETER Conv_Size_KB_TxNmtQ = 2, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_TxNmtQ
PARAMETER Conv_Size_KB_TxGenQ = 2, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_TxGenQ
PARAMETER Conv_Size_KB_TxSynQ = 2, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_TxSynQ
PARAMETER Conv_Size_KB_TxVetQ = 2, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_TxVetQ
PARAMETER Conv_Size_KB_RxVetQ = 1, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_RxVetQ
PARAMETER Conv_Size_KB_K2UQ = 8, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_K2UQ
PARAMETER Conv_Size_KB_U2KQ = 8, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_U2KQ
PARAMETER Conv_Size_B_Tpdo = 12288, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_Tpdo
PARAMETER Conv_Size_B_Rpdo = 24576, DT = INTEGER, IPLEVEL_UPDATE_VALUE_PROC = calc_size_Rpdo
## Ports
## Host Interface IP PCP Ports
PORT S_AXI_PCP_ACLK = "", DIR = I, SIGIS = CLK, BUS = S_AXI_PCP
PORT S_AXI_PCP_ARESETN = ARESETN, DIR = I, SIGIS = RST, BUS = S_AXI_PCP
PORT S_AXI_PCP_AWADDR = AWADDR, DIR = I, VEC = [(C_S_AXI_PCP_ADDR_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI_PCP
PORT S_AXI_PCP_AWVALID = AWVALID, DIR = I, BUS = S_AXI_PCP
PORT S_AXI_PCP_WDATA = WDATA, DIR = I, VEC = [(C_S_AXI_PCP_DATA_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI_PCP
PORT S_AXI_PCP_WSTRB = WSTRB, DIR = I, VEC = [((C_S_AXI_PCP_DATA_WIDTH/8)-1):0], ENDIAN = LITTLE, BUS = S_AXI_PCP
PORT S_AXI_PCP_WVALID = WVALID, DIR = I, BUS = S_AXI_PCP
PORT S_AXI_PCP_BREADY = BREADY, DIR = I, BUS = S_AXI_PCP
PORT S_AXI_PCP_ARADDR = ARADDR, DIR = I, VEC = [(C_S_AXI_PCP_ADDR_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI_PCP
PORT S_AXI_PCP_ARVALID = ARVALID, DIR = I, BUS = S_AXI_PCP
PORT S_AXI_PCP_RREADY = RREADY, DIR = I, BUS = S_AXI_PCP
PORT S_AXI_PCP_ARREADY = ARREADY, DIR = O, BUS = S_AXI_PCP
PORT S_AXI_PCP_RDATA = RDATA, DIR = O, VEC = [(C_S_AXI_PCP_DATA_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI_PCP
PORT S_AXI_PCP_RRESP = RRESP, DIR = O, VEC = [1:0], BUS = S_AXI_PCP
PORT S_AXI_PCP_RVALID = RVALID, DIR = O, BUS = S_AXI_PCP
PORT S_AXI_PCP_WREADY = WREADY, DIR = O, BUS = S_AXI_PCP
PORT S_AXI_PCP_BRESP = BRESP, DIR = O, VEC = [1:0], BUS = S_AXI_PCP
PORT S_AXI_PCP_BVALID = BVALID, DIR = O, BUS = S_AXI_PCP
PORT S_AXI_PCP_AWREADY = AWREADY, DIR = O, BUS = S_AXI_PCP

## Host Interface IP Host Internal AXI Ports
PORT S_AXI_HOST_ACLK = "", DIR = I, SIGIS = CLK, BUS = S_AXI_HOST
PORT S_AXI_HOST_ARESETN = ARESETN, DIR = I, SIGIS = RST, BUS = S_AXI_HOST
PORT S_AXI_HOST_AWADDR = AWADDR, DIR = I, VEC = [(C_S_AXI_PCP_ADDR_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI_HOST
PORT S_AXI_HOST_AWVALID = AWVALID, DIR = I, BUS = S_AXI_HOST
PORT S_AXI_HOST_WDATA = WDATA, DIR = I, VEC = [(C_S_AXI_PCP_DATA_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI_HOST
PORT S_AXI_HOST_WSTRB = WSTRB, DIR = I, VEC = [((C_S_AXI_PCP_DATA_WIDTH/8)-1):0], ENDIAN = LITTLE, BUS = S_AXI_HOST
PORT S_AXI_HOST_WVALID = WVALID, DIR = I, BUS = S_AXI_HOST
PORT S_AXI_HOST_BREADY = BREADY, DIR = I, BUS = S_AXI_HOST
PORT S_AXI_HOST_ARADDR = ARADDR, DIR = I, VEC = [(C_S_AXI_PCP_ADDR_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI_HOST
PORT S_AXI_HOST_ARVALID = ARVALID, DIR = I, BUS = S_AXI_HOST
PORT S_AXI_HOST_RREADY = RREADY, DIR = I, BUS = S_AXI_HOST
PORT S_AXI_HOST_ARREADY = ARREADY, DIR = O, BUS = S_AXI_HOST
PORT S_AXI_HOST_RDATA = RDATA, DIR = O, VEC = [(C_S_AXI_PCP_DATA_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI_HOST
PORT S_AXI_HOST_RRESP = RRESP, DIR = O, VEC = [1:0], BUS = S_AXI_HOST
PORT S_AXI_HOST_RVALID = RVALID, DIR = O, BUS = S_AXI_HOST
PORT S_AXI_HOST_WREADY = WREADY, DIR = O, BUS = S_AXI_HOST
PORT S_AXI_HOST_BRESP = BRESP, DIR = O, VEC = [1:0], BUS = S_AXI_HOST
PORT S_AXI_HOST_BVALID = BVALID, DIR = O, BUS = S_AXI_HOST
PORT S_AXI_HOST_AWREADY = AWREADY, DIR = O, BUS = S_AXI_HOST

## Host Interface Bridge Ports
PORT M_AXI_ACLK = "", BUS = M_AXI_PCP, DIR = I, SIGIS = CLK
PORT M_AXI_ARESETN = ARESETN, BUS = M_AXI_PCP, DIR = I, SIGIS = RST
PORT M_AXI_AWADDR = AWADDR, BUS = M_AXI_PCP, DIR = O, VEC = [(C_M_AXI_ADDR_WIDTH-1):0]
PORT M_AXI_AWPROT = AWPROT, BUS = M_AXI_PCP, DIR = O, VEC = [2:0]
PORT M_AXI_AWVALID = AWVALID, BUS = M_AXI_PCP, DIR = O
PORT M_AXI_AWREADY = AWREADY, BUS = M_AXI_PCP, DIR = I
PORT M_AXI_WDATA = WDATA, BUS = M_AXI_PCP, DIR = O, VEC = [(C_M_AXI_DATA_WIDTH-1):0]
PORT M_AXI_WSTRB = WSTRB, BUS = M_AXI_PCP, DIR = O, VEC = [((C_M_AXI_DATA_WIDTH/8) -1):0]
PORT M_AXI_WVALID = WVALID, BUS = M_AXI_PCP, DIR = O
PORT M_AXI_WREADY = WREADY, BUS = M_AXI_PCP, DIR = I
PORT M_AXI_WLAST = WLAST,  BUS = M_AXI_PCP, DIR = O
PORT M_AXI_BRESP = BRESP, BUS = M_AXI_PCP, DIR = I, VEC = [1:0]
PORT M_AXI_BVALID = BVALID, BUS = M_AXI_PCP, DIR = I
PORT M_AXI_BREADY = BREADY, BUS = M_AXI_PCP, DIR = O
PORT M_AXI_ARADDR = ARADDR, BUS = M_AXI_PCP, DIR = O, VEC = [(C_M_AXI_ADDR_WIDTH-1):0
PORT M_AXI_ARPROT = ARPROT, BUS = M_AXI_PCP, DIR = O, VEC = [2:0]
PORT M_AXI_ARVALID = ARVALID, BUS = M_AXI_PCP, DIR = O
PORT M_AXI_ARREADY = ARREADY, BUS = M_AXI_PCP, DIR = I
PORT M_AXI_RDATA = RDATA, BUS = M_AXI_PCP, DIR = I, VEC = [(C_M_AXI_DATA_WIDTH-1):0]
PORT M_AXI_RRESP = RRESP, BUS = M_AXI_PCP, DIR = I, VEC = [1:0]
PORT M_AXI_RVALID = RVALID, BUS = M_AXI_PCP, DIR = I
PORT M_AXI_RREADY = RREADY, BUS = M_AXI_PCP, DIR = O

## Host Interface Signals
PORT irqSync_irq = "", DIR = I, SIGIS = INTERRUPT, SENSITIVITY = LEVEL_HIGH
PORT irqOut_irq = "", DIR = O, SIGIS = INTERRUPT, SENSITIVITY = LEVEL_HIGH
PORT iExtSync_exsync = "" , DIR = I, IO_IF = LED
PORT iNodeId_nodeid = "" , DIR = I, VEC = [7:0], IO_IF = LED
PORT oPlkLed_lederr = "" , DIR = O, IO_IF = LED
PORT oPlkLed_ledst = "" , DIR = O, IO_IF = LED
## Parallel Interface Signals
PORT iExtSync_exsync = "", DIR = I, IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT iParHost_chipselect = "", DIR = I, IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT iParHost_read = "", DIR = I, IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT iParHost_write = "", DIR = I, IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT oParHost_acknowledge = "", DIR = O, IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT iParHost_byteenable = "", DIR = I, VEC =[(gParallelDataWidth/8)-1:0], IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT iParHost_address = "", DIR = I, VEC =[15:0], IO_IF = PAP, ISVALID = (gHostIfType == 1)

PORT iParHost_data_io = "", DIR = I, VEC =[gParallelDataWidth-1:0],IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT oParHost_data_io = "", DIR = O, VEC =[gParallelDataWidth-1:0],IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT oParHost_data_io_tri = "", DIR = O, IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT ioParHost_data_io = "", DIR = INOUT, VEC =[gParallelDataWidth-1:0],  THREE_STATE = TRUE, TRI_I = iParHost_data_io, TRI_O = oParHost_data_io, TRI_T = oParHost_data_io_tri, IO_IF = PAP, ISVALID = (gHostIfType == 1)
PORT iParHost_addressLatchEnable = "", DIR = I, IO_IF = PAP, ISVALID = (gParallelMultiplex == 1)

PORT iParHost_addressData_io = "", DIR = I, VEC =[gParallelDataWidth-1:0], IO_IF = PAP, ISVALID = (gParallelMultiplex == 1)
PORT oParHost_addressData_io = "", DIR = O, VEC =[gParallelDataWidth-1:0], IO_IF = PAP, ISVALID = (gParallelMultiplex == 1)
PORT oParHost_addressData_tri = "", DIR =O, IO_IF = PAP, ISVALID = (gParallelMultiplex == 1)
PORT ioParHost_addressData_io = "", DIR = INOUT, VEC =[gParallelDataWidth-1:0], THREE_STATE = TRUE, TRI_I = iParHost_addressData_io, TRI_O = oParHost_addressData_io, TRI_T = oParHost_addressData_tri, IO_IF = PAP, ISVALID = (gParallelMultiplex == 1)

END
